{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/metadata-parser.ts"],"sourcesContent":["import type { CallMetadata } from '@/types';\n\n/**\n * Filename pattern: [LastName, FirstName]_AgentID-Phone_Timestamp(CallID).wav\n * Example: [Stevens, Rebecca]_218-07786515254_20251112120634(2367).wav\n */\n\nexport interface ParseResult {\n  success: boolean;\n  metadata?: CallMetadata;\n  error?: string;\n}\n\n/**\n * Parse call metadata from standardized filename\n * @param filename - The full filename including .wav extension\n * @returns ParseResult with metadata or error\n */\nexport function parseCallFilename(filename: string): ParseResult {\n  // Remove .wav extension if present\n  const nameWithoutExt = filename.replace(/\\.wav$/i, '');\n\n  // Regex pattern to extract metadata\n  // Pattern: [LastName, FirstName]_AgentID-Phone_Timestamp(CallID)\n  const pattern = /^\\[([^,]+),\\s*([^\\]]+)\\]_(\\d+)-(\\d+)_(\\d{14})\\((\\d+)\\)$/;\n\n  const match = nameWithoutExt.match(pattern);\n\n  if (!match) {\n    return {\n      success: false,\n      error: `Invalid filename format. Expected: [LastName, FirstName]_AgentID-Phone_Timestamp(CallID).wav`,\n    };\n  }\n\n  const [, lastName, firstName, agentId, phoneNumber, timestamp, callId] = match;\n\n  // Parse timestamp (format: YYYYMMDDHHmmss)\n  const year = parseInt(timestamp.substring(0, 4));\n  const month = parseInt(timestamp.substring(4, 6)) - 1; // Month is 0-indexed\n  const day = parseInt(timestamp.substring(6, 8));\n  const hour = parseInt(timestamp.substring(8, 10));\n  const minute = parseInt(timestamp.substring(10, 12));\n  const second = parseInt(timestamp.substring(12, 14));\n\n  const parsedDate = new Date(year, month, day, hour, minute, second);\n\n  // Validate date\n  if (isNaN(parsedDate.getTime())) {\n    return {\n      success: false,\n      error: `Invalid timestamp in filename: ${timestamp}`,\n    };\n  }\n\n  // Construct full agent name\n  const agentName = `${firstName.trim()} ${lastName.trim()}`;\n\n  const metadata: CallMetadata = {\n    agentName,\n    agentId: agentId.trim(),\n    phoneNumber: phoneNumber.trim(),\n    callId: callId.trim(),\n    timestamp: parsedDate,\n  };\n\n  return {\n    success: true,\n    metadata,\n  };\n}\n\n/**\n * Validate if filename matches expected pattern\n * @param filename - The filename to validate\n * @returns boolean indicating if filename is valid\n */\nexport function isValidCallFilename(filename: string): boolean {\n  const result = parseCallFilename(filename);\n  return result.success;\n}\n\n/**\n * Extract just the agent name from filename\n * @param filename - The filename\n * @returns Agent name or null if invalid\n */\nexport function extractAgentName(filename: string): string | null {\n  const result = parseCallFilename(filename);\n  return result.success ? result.metadata!.agentName : null;\n}\n\n/**\n * Format timestamp for display\n * @param date - Date object\n * @returns Formatted string\n */\nexport function formatCallTimestamp(date: Date): string {\n  return date.toLocaleString('en-GB', {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n}\n\n/**\n * Batch parse multiple filenames\n * @param filenames - Array of filenames\n * @returns Array of parse results\n */\nexport function parseCallFilenames(filenames: string[]): ParseResult[] {\n  return filenames.map(parseCallFilename);\n}\n\n/**\n * Get validation summary for multiple files\n * @param filenames - Array of filenames\n * @returns Summary of valid/invalid files\n */\nexport function validateBatch(filenames: string[]): {\n  valid: string[];\n  invalid: Array<{ filename: string; error: string }>;\n  totalValid: number;\n  totalInvalid: number;\n} {\n  const valid: string[] = [];\n  const invalid: Array<{ filename: string; error: string }> = [];\n\n  filenames.forEach((filename) => {\n    const result = parseCallFilename(filename);\n    if (result.success) {\n      valid.push(filename);\n    } else {\n      invalid.push({ filename, error: result.error! });\n    }\n  });\n\n  return {\n    valid,\n    invalid,\n    totalValid: valid.length,\n    totalInvalid: invalid.length,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAkBO,SAAS,kBAAkB,QAAgB;IAChD,mCAAmC;IACnC,MAAM,iBAAiB,SAAS,OAAO,CAAC,WAAW;IAEnD,oCAAoC;IACpC,iEAAiE;IACjE,MAAM,UAAU;IAEhB,MAAM,QAAQ,eAAe,KAAK,CAAC;IAEnC,IAAI,CAAC,OAAO;QACV,OAAO;YACL,SAAS;YACT,OAAO,CAAC,4FAA4F,CAAC;QACvG;IACF;IAEA,MAAM,GAAG,UAAU,WAAW,SAAS,aAAa,WAAW,OAAO,GAAG;IAEzE,2CAA2C;IAC3C,MAAM,OAAO,SAAS,UAAU,SAAS,CAAC,GAAG;IAC7C,MAAM,QAAQ,SAAS,UAAU,SAAS,CAAC,GAAG,MAAM,GAAG,qBAAqB;IAC5E,MAAM,MAAM,SAAS,UAAU,SAAS,CAAC,GAAG;IAC5C,MAAM,OAAO,SAAS,UAAU,SAAS,CAAC,GAAG;IAC7C,MAAM,SAAS,SAAS,UAAU,SAAS,CAAC,IAAI;IAChD,MAAM,SAAS,SAAS,UAAU,SAAS,CAAC,IAAI;IAEhD,MAAM,aAAa,IAAI,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQ;IAE5D,gBAAgB;IAChB,IAAI,MAAM,WAAW,OAAO,KAAK;QAC/B,OAAO;YACL,SAAS;YACT,OAAO,CAAC,+BAA+B,EAAE,WAAW;QACtD;IACF;IAEA,4BAA4B;IAC5B,MAAM,YAAY,GAAG,UAAU,IAAI,GAAG,CAAC,EAAE,SAAS,IAAI,IAAI;IAE1D,MAAM,WAAyB;QAC7B;QACA,SAAS,QAAQ,IAAI;QACrB,aAAa,YAAY,IAAI;QAC7B,QAAQ,OAAO,IAAI;QACnB,WAAW;IACb;IAEA,OAAO;QACL,SAAS;QACT;IACF;AACF;AAOO,SAAS,oBAAoB,QAAgB;IAClD,MAAM,SAAS,kBAAkB;IACjC,OAAO,OAAO,OAAO;AACvB;AAOO,SAAS,iBAAiB,QAAgB;IAC/C,MAAM,SAAS,kBAAkB;IACjC,OAAO,OAAO,OAAO,GAAG,OAAO,QAAQ,CAAE,SAAS,GAAG;AACvD;AAOO,SAAS,oBAAoB,IAAU;IAC5C,OAAO,KAAK,cAAc,CAAC,SAAS;QAClC,MAAM;QACN,OAAO;QACP,KAAK;QACL,MAAM;QACN,QAAQ;QACR,QAAQ;IACV;AACF;AAOO,SAAS,mBAAmB,SAAmB;IACpD,OAAO,UAAU,GAAG,CAAC;AACvB;AAOO,SAAS,cAAc,SAAmB;IAM/C,MAAM,QAAkB,EAAE;IAC1B,MAAM,UAAsD,EAAE;IAE9D,UAAU,OAAO,CAAC,CAAC;QACjB,MAAM,SAAS,kBAAkB;QACjC,IAAI,OAAO,OAAO,EAAE;YAClB,MAAM,IAAI,CAAC;QACb,OAAO;YACL,QAAQ,IAAI,CAAC;gBAAE;gBAAU,OAAO,OAAO,KAAK;YAAE;QAChD;IACF;IAEA,OAAO;QACL;QACA;QACA,YAAY,MAAM,MAAM;QACxB,cAAc,QAAQ,MAAM;IAC9B;AACF","debugId":null}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/storage.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport type { Call, Transcript } from '@/types';\n\nconst DATA_DIR = path.join(process.cwd(), 'data');\nconst CALLS_FILE = path.join(DATA_DIR, 'calls', 'calls.json');\nconst UPLOADS_DIR = path.join(DATA_DIR, 'uploads');\nconst TRANSCRIPTS_DIR = path.join(DATA_DIR, 'transcripts');\nconst ANALYSES_DIR = path.join(DATA_DIR, 'analyses');\n\n/**\n * Ensure required directories exist\n */\nexport async function ensureDirectories() {\n  await fs.mkdir(path.join(DATA_DIR, 'calls'), { recursive: true });\n  await fs.mkdir(UPLOADS_DIR, { recursive: true });\n  await fs.mkdir(TRANSCRIPTS_DIR, { recursive: true });\n  await fs.mkdir(ANALYSES_DIR, { recursive: true });\n}\n\n/**\n * Read all calls from JSON storage\n */\nexport async function readCalls(): Promise<Call[]> {\n  try {\n    const data = await fs.readFile(CALLS_FILE, 'utf-8');\n    const calls = JSON.parse(data);\n\n    // Remove duplicates based on ID (keep first occurrence)\n    const seen = new Set<string>();\n    const uniqueCalls = calls.filter((call: Call) => {\n      if (seen.has(call.id)) {\n        return false;\n      }\n      seen.add(call.id);\n      return true;\n    });\n\n    // If duplicates were found, write the deduplicated list back\n    if (uniqueCalls.length !== calls.length) {\n      console.log(`Removed ${calls.length - uniqueCalls.length} duplicate call(s)`);\n      await writeCalls(uniqueCalls);\n    }\n\n    return uniqueCalls;\n  } catch (error) {\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n/**\n * Write calls to JSON storage\n */\nexport async function writeCalls(calls: Call[]): Promise<void> {\n  await ensureDirectories();\n  await fs.writeFile(CALLS_FILE, JSON.stringify(calls, null, 2), 'utf-8');\n}\n\n/**\n * Add a new call record\n */\nexport async function addCall(call: Call): Promise<Call> {\n  const calls = await readCalls();\n\n  // Check if call already exists\n  const existingIndex = calls.findIndex((c) => c.id === call.id);\n  if (existingIndex !== -1) {\n    // Update existing call instead of adding duplicate\n    calls[existingIndex] = call;\n  } else {\n    calls.push(call);\n  }\n\n  await writeCalls(calls);\n  return call;\n}\n\n/**\n * Get call by ID\n */\nexport async function getCallById(id: string): Promise<Call | null> {\n  const calls = await readCalls();\n  return calls.find((call) => call.id === id) || null;\n}\n\n/**\n * Update call record\n */\nexport async function updateCall(id: string, updates: Partial<Call>): Promise<Call | null> {\n  const calls = await readCalls();\n  const index = calls.findIndex((call) => call.id === id);\n\n  if (index === -1) {\n    return null;\n  }\n\n  calls[index] = {\n    ...calls[index],\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await writeCalls(calls);\n  return calls[index];\n}\n\n/**\n * Save uploaded file\n */\nexport async function saveUploadedFile(\n  buffer: Buffer,\n  filename: string\n): Promise<string> {\n  await ensureDirectories();\n  const filepath = path.join(UPLOADS_DIR, filename);\n  await fs.writeFile(filepath, buffer);\n  return filepath;\n}\n\n/**\n * Get upload path for a file\n */\nexport function getUploadPath(filename: string): string {\n  return path.join(UPLOADS_DIR, filename);\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filename: string): Promise<boolean> {\n  try {\n    await fs.access(getUploadPath(filename));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate unique call ID\n */\nexport function generateCallId(): string {\n  return `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Save transcript to JSON file\n */\nexport async function saveTranscript(transcript: Transcript): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(TRANSCRIPTS_DIR, `${transcript.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(transcript, null, 2), 'utf-8');\n}\n\n/**\n * Save transcript as plain text\n */\nexport async function saveTranscriptAsText(callId: string, textContent: string): Promise<void> {\n  await ensureDirectories();\n  const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n  await fs.writeFile(txtPath, textContent, 'utf-8');\n}\n\n/**\n * Get transcript by call ID\n */\nexport async function getTranscript(callId: string): Promise<Transcript | null> {\n  try {\n    const jsonPath = path.join(TRANSCRIPTS_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get transcript text by call ID\n */\nexport async function getTranscriptText(callId: string): Promise<string | null> {\n  try {\n    const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n    return await fs.readFile(txtPath, 'utf-8');\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Save analysis to JSON file\n */\nexport async function saveAnalysis(analysis: any): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(ANALYSES_DIR, `${analysis.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(analysis, null, 2), 'utf-8');\n}\n\n/**\n * Get analysis by call ID\n */\nexport async function getAnalysis(callId: string): Promise<any | null> {\n  try {\n    const jsonPath = path.join(ANALYSES_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get complete call data (call + transcript + analysis)\n */\nexport async function getCompleteCallData(callId: string): Promise<{\n  call: Call | null;\n  transcript: Transcript | null;\n  analysis: any | null;\n}> {\n  const [call, transcript, analysis] = await Promise.all([\n    getCallById(callId),\n    getTranscript(callId),\n    getAnalysis(callId),\n  ]);\n\n  return { call, transcript, analysis };\n}\n\n/**\n * Delete call and all associated data\n */\nexport async function deleteCall(callId: string): Promise<boolean> {\n  try {\n    // Remove from calls.json\n    const calls = await readCalls();\n    const filtered = calls.filter((call) => call.id !== callId);\n    await writeCalls(filtered);\n\n    // Delete transcript files\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.json`));\n    } catch {}\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.txt`));\n    } catch {}\n\n    // Delete analysis file\n    try {\n      await fs.unlink(path.join(ANALYSES_DIR, `${callId}.json`));\n    } catch {}\n\n    // Delete uploaded audio file (if exists)\n    const call = await getCallById(callId);\n    if (call?.filename) {\n      try {\n        await fs.unlink(getUploadPath(call.filename));\n      } catch {}\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting call:', error);\n    return false;\n  }\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalCalls: number;\n  uploadedCalls: number;\n  transcribedCalls: number;\n  analyzedCalls: number;\n  errorCalls: number;\n  totalStorageBytes: number;\n}> {\n  const calls = await readCalls();\n\n  const stats = {\n    totalCalls: calls.length,\n    uploadedCalls: calls.filter((c) => c.status === 'pending').length,\n    transcribedCalls: calls.filter((c) => c.status === 'analyzing' || c.status === 'complete').length,\n    analyzedCalls: calls.filter((c) => c.status === 'complete').length,\n    errorCalls: calls.filter((c) => c.status === 'error').length,\n    totalStorageBytes: 0,\n  };\n\n  // Calculate total storage size\n  try {\n    const transcriptFiles = await fs.readdir(TRANSCRIPTS_DIR);\n    const analysisFiles = await fs.readdir(ANALYSES_DIR);\n    const uploadFiles = await fs.readdir(UPLOADS_DIR);\n\n    for (const file of transcriptFiles) {\n      const stat = await fs.stat(path.join(TRANSCRIPTS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of analysisFiles) {\n      const stat = await fs.stat(path.join(ANALYSES_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of uploadFiles) {\n      const stat = await fs.stat(path.join(UPLOADS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n  } catch (error) {\n    console.error('Error calculating storage size:', error);\n  }\n\n  return stats;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 434, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/app/api/upload/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { parseCallFilename } from '@/lib/metadata-parser';\nimport { addCall, saveUploadedFile, generateCallId } from '@/lib/storage';\nimport type { Call, ApiResponse } from '@/types';\n\nconst MAX_FILE_SIZE = 25 * 1024 * 1024; // 25MB (OpenAI Whisper limit)\nconst ALLOWED_MIME_TYPES = ['audio/wav', 'audio/x-wav', 'audio/wave'];\n\n/**\n * POST /api/upload\n * Upload WAV file(s) for processing\n */\nexport async function POST(req: NextRequest) {\n  try {\n    // Get the form data directly\n    const formData = await req.formData();\n    const files = formData.getAll('files') as File[];\n\n    if (!files || files.length === 0) {\n      return NextResponse.json<ApiResponse<null>>(\n        {\n          success: false,\n          error: 'No files provided',\n        },\n        { status: 400 }\n      );\n    }\n\n    const uploadedCalls: Call[] = [];\n    const errors: string[] = [];\n\n    for (const file of files) {\n      try {\n        // Validate file type\n        if (!ALLOWED_MIME_TYPES.includes(file.type)) {\n          errors.push(`${file.name}: Invalid file type. Only WAV files are accepted.`);\n          continue;\n        }\n\n        // Validate file size\n        if (file.size > MAX_FILE_SIZE) {\n          errors.push(`${file.name}: File size exceeds 25MB limit (required by OpenAI Whisper API).`);\n          continue;\n        }\n\n        // Parse filename to extract metadata\n        const parseResult = parseCallFilename(file.name);\n        if (!parseResult.success) {\n          errors.push(`${file.name}: ${parseResult.error}`);\n          continue;\n        }\n\n        const metadata = parseResult.metadata!;\n\n        // Read file buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const buffer = Buffer.from(arrayBuffer);\n\n        // Save file to uploads directory\n        const savedPath = await saveUploadedFile(buffer, file.name);\n\n        // Create call record\n        const call: Call = {\n          id: generateCallId(),\n          filename: file.name,\n          agentName: metadata.agentName,\n          agentId: metadata.agentId,\n          phoneNumber: metadata.phoneNumber,\n          callId: metadata.callId,\n          timestamp: metadata.timestamp,\n          duration: 0, // Will be set after transcription\n          status: 'pending',\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        };\n\n        // Store call metadata\n        const savedCall = await addCall(call);\n        uploadedCalls.push(savedCall);\n\n        // Trigger transcription asynchronously (don't wait)\n        fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/transcribe`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ callId: savedCall.id }),\n        }).catch((err) => console.error('Failed to trigger transcription:', err));\n      } catch (fileError) {\n        errors.push(`${file.name}: ${(fileError as Error).message}`);\n      }\n    }\n\n    // Return response\n    if (uploadedCalls.length === 0) {\n      return NextResponse.json<ApiResponse<null>>(\n        {\n          success: false,\n          error: 'No files were successfully uploaded',\n          message: errors.join('; '),\n        },\n        { status: 400 }\n      );\n    }\n\n    return NextResponse.json<ApiResponse<{ calls: Call[]; errors: string[] }>>(\n      {\n        success: true,\n        data: {\n          calls: uploadedCalls,\n          errors,\n        },\n        message: `Successfully uploaded ${uploadedCalls.length} file(s)${\n          errors.length > 0 ? ` with ${errors.length} error(s)` : ''\n        }`,\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error('Upload error:', error);\n    return NextResponse.json<ApiResponse<null>>(\n      {\n        success: false,\n        error: 'Internal server error',\n        message: (error as Error).message,\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}