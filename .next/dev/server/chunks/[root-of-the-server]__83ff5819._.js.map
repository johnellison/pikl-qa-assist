{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/storage.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport type { Call, Transcript } from '@/types';\n\nconst DATA_DIR = path.join(process.cwd(), 'data');\nconst CALLS_FILE = path.join(DATA_DIR, 'calls', 'calls.json');\nconst UPLOADS_DIR = path.join(DATA_DIR, 'uploads');\nconst TRANSCRIPTS_DIR = path.join(DATA_DIR, 'transcripts');\nconst ANALYSES_DIR = path.join(DATA_DIR, 'analyses');\n\n/**\n * Ensure required directories exist\n */\nexport async function ensureDirectories() {\n  await fs.mkdir(path.join(DATA_DIR, 'calls'), { recursive: true });\n  await fs.mkdir(UPLOADS_DIR, { recursive: true });\n  await fs.mkdir(TRANSCRIPTS_DIR, { recursive: true });\n  await fs.mkdir(ANALYSES_DIR, { recursive: true });\n}\n\n/**\n * Read all calls from JSON storage\n */\nexport async function readCalls(): Promise<Call[]> {\n  try {\n    const data = await fs.readFile(CALLS_FILE, 'utf-8');\n    const calls = JSON.parse(data);\n\n    // Remove duplicates based on ID (keep first occurrence)\n    const seen = new Set<string>();\n    const uniqueCalls = calls.filter((call: Call) => {\n      if (seen.has(call.id)) {\n        return false;\n      }\n      seen.add(call.id);\n      return true;\n    });\n\n    // If duplicates were found, write the deduplicated list back\n    if (uniqueCalls.length !== calls.length) {\n      console.log(`Removed ${calls.length - uniqueCalls.length} duplicate call(s)`);\n      await writeCalls(uniqueCalls);\n    }\n\n    // Sort by updatedAt descending (most recent first)\n    const sortedCalls = uniqueCalls.sort((a, b) => {\n      const dateA = new Date(a.updatedAt).getTime();\n      const dateB = new Date(b.updatedAt).getTime();\n      return dateB - dateA; // Descending order\n    });\n\n    return sortedCalls;\n  } catch (error) {\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n// Mutex lock for preventing concurrent writes\nlet writeQueue: Promise<void> = Promise.resolve();\n\n/**\n * Write calls to JSON storage with mutex lock to prevent corruption\n */\nexport async function writeCalls(calls: Call[]): Promise<void> {\n  // Wait for any pending writes to complete\n  await writeQueue;\n\n  // Queue this write operation\n  writeQueue = (async () => {\n    try {\n      await ensureDirectories();\n      await fs.writeFile(CALLS_FILE, JSON.stringify(calls, null, 2), 'utf-8');\n    } catch (error) {\n      console.error('[STORAGE] Failed to write calls:', error);\n      throw error;\n    }\n  })();\n\n  await writeQueue;\n}\n\n/**\n * Add a new call record\n */\nexport async function addCall(call: Call): Promise<Call> {\n  const calls = await readCalls();\n\n  // Check if call already exists\n  const existingIndex = calls.findIndex((c) => c.id === call.id);\n  if (existingIndex !== -1) {\n    // Update existing call instead of adding duplicate\n    calls[existingIndex] = call;\n  } else {\n    calls.push(call);\n  }\n\n  await writeCalls(calls);\n  return call;\n}\n\n/**\n * Get call by ID\n */\nexport async function getCallById(id: string): Promise<Call | null> {\n  const calls = await readCalls();\n  return calls.find((call) => call.id === id) || null;\n}\n\n/**\n * Update call record\n */\nexport async function updateCall(id: string, updates: Partial<Call>): Promise<Call | null> {\n  const calls = await readCalls();\n  const index = calls.findIndex((call) => call.id === id);\n\n  if (index === -1) {\n    return null;\n  }\n\n  calls[index] = {\n    ...calls[index],\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await writeCalls(calls);\n  return calls[index];\n}\n\n/**\n * Save uploaded file\n */\nexport async function saveUploadedFile(\n  buffer: Buffer,\n  filename: string\n): Promise<string> {\n  await ensureDirectories();\n  const filepath = path.join(UPLOADS_DIR, filename);\n  await fs.writeFile(filepath, buffer);\n  return filepath;\n}\n\n/**\n * Get upload path for a file\n */\nexport function getUploadPath(filename: string): string {\n  return path.join(UPLOADS_DIR, filename);\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filename: string): Promise<boolean> {\n  try {\n    await fs.access(getUploadPath(filename));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate unique call ID\n */\nexport function generateCallId(): string {\n  return `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Save transcript to JSON file\n */\nexport async function saveTranscript(transcript: Transcript): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(TRANSCRIPTS_DIR, `${transcript.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(transcript, null, 2), 'utf-8');\n}\n\n/**\n * Save transcript as plain text\n */\nexport async function saveTranscriptAsText(callId: string, textContent: string): Promise<void> {\n  await ensureDirectories();\n  const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n  await fs.writeFile(txtPath, textContent, 'utf-8');\n}\n\n/**\n * Get transcript by call ID\n */\nexport async function getTranscript(callId: string): Promise<Transcript | null> {\n  try {\n    const jsonPath = path.join(TRANSCRIPTS_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get transcript text by call ID\n */\nexport async function getTranscriptText(callId: string): Promise<string | null> {\n  try {\n    const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n    return await fs.readFile(txtPath, 'utf-8');\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Save analysis to JSON file\n */\nexport async function saveAnalysis(analysis: any): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(ANALYSES_DIR, `${analysis.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(analysis, null, 2), 'utf-8');\n}\n\n/**\n * Get analysis by call ID\n */\nexport async function getAnalysis(callId: string): Promise<any | null> {\n  try {\n    const jsonPath = path.join(ANALYSES_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get complete call data (call + transcript + analysis)\n */\nexport async function getCompleteCallData(callId: string): Promise<{\n  call: Call | null;\n  transcript: Transcript | null;\n  analysis: any | null;\n}> {\n  const [call, transcript, analysis] = await Promise.all([\n    getCallById(callId),\n    getTranscript(callId),\n    getAnalysis(callId),\n  ]);\n\n  return { call, transcript, analysis };\n}\n\n/**\n * Delete call and all associated data\n */\nexport async function deleteCall(callId: string): Promise<boolean> {\n  try {\n    // Remove from calls.json\n    const calls = await readCalls();\n    const filtered = calls.filter((call) => call.id !== callId);\n    await writeCalls(filtered);\n\n    // Delete transcript files\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.json`));\n    } catch {}\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.txt`));\n    } catch {}\n\n    // Delete analysis file\n    try {\n      await fs.unlink(path.join(ANALYSES_DIR, `${callId}.json`));\n    } catch {}\n\n    // Delete uploaded audio file (if exists)\n    const call = await getCallById(callId);\n    if (call?.filename) {\n      try {\n        await fs.unlink(getUploadPath(call.filename));\n      } catch {}\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting call:', error);\n    return false;\n  }\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalCalls: number;\n  uploadedCalls: number;\n  transcribedCalls: number;\n  analyzedCalls: number;\n  errorCalls: number;\n  totalStorageBytes: number;\n}> {\n  const calls = await readCalls();\n\n  const stats = {\n    totalCalls: calls.length,\n    uploadedCalls: calls.filter((c) => c.status === 'pending').length,\n    transcribedCalls: calls.filter((c) => c.status === 'analyzing' || c.status === 'complete').length,\n    analyzedCalls: calls.filter((c) => c.status === 'complete').length,\n    errorCalls: calls.filter((c) => c.status === 'error').length,\n    totalStorageBytes: 0,\n  };\n\n  // Calculate total storage size\n  try {\n    const transcriptFiles = await fs.readdir(TRANSCRIPTS_DIR);\n    const analysisFiles = await fs.readdir(ANALYSES_DIR);\n    const uploadFiles = await fs.readdir(UPLOADS_DIR);\n\n    for (const file of transcriptFiles) {\n      const stat = await fs.stat(path.join(TRANSCRIPTS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of analysisFiles) {\n      const stat = await fs.stat(path.join(ANALYSES_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of uploadFiles) {\n      const stat = await fs.stat(path.join(UPLOADS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n  } catch (error) {\n    console.error('Error calculating storage size:', error);\n  }\n\n  return stats;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/app/api/audio/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { readCalls } from '@/lib/storage';\n\n/**\n * GET /api/audio/[id]\n * Serves the audio file for a given call ID\n */\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params;\n\n    // Get call data to find the filename\n    const calls = await readCalls();\n    const call = calls.find((c) => c.id === id);\n\n    if (!call || !call.filename) {\n      return NextResponse.json(\n        { error: 'Call not found or no audio file' },\n        { status: 404 }\n      );\n    }\n\n    // Construct the file path\n    const uploadsDir = path.join(process.cwd(), 'data', 'uploads');\n    const filePath = path.join(uploadsDir, call.filename);\n\n    // Check if file exists\n    try {\n      await fs.access(filePath);\n    } catch {\n      return NextResponse.json(\n        { error: 'Audio file not found' },\n        { status: 404 }\n      );\n    }\n\n    // Read the file\n    const fileBuffer = await fs.readFile(filePath);\n\n    // Determine content type based on file extension\n    const ext = path.extname(call.filename).toLowerCase();\n    let contentType = 'audio/wav';\n    if (ext === '.mp3') contentType = 'audio/mpeg';\n    if (ext === '.m4a') contentType = 'audio/mp4';\n    if (ext === '.ogg') contentType = 'audio/ogg';\n\n    // Return the audio file with appropriate headers\n    return new NextResponse(fileBuffer, {\n      status: 200,\n      headers: {\n        'Content-Type': contentType,\n        'Content-Length': fileBuffer.length.toString(),\n        'Accept-Ranges': 'bytes',\n        'Cache-Control': 'public, max-age=31536000', // Cache for 1 year\n      },\n    });\n  } catch (error) {\n    console.error('[API] Error serving audio:', error);\n    return NextResponse.json(\n      { error: 'Failed to serve audio file' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAMO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QAErB,qCAAqC;QACrC,MAAM,QAAQ,MAAM,IAAA,oIAAS;QAC7B,MAAM,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;QAExC,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;YAC3B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,0BAA0B;QAC1B,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;QACpD,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,YAAY,KAAK,QAAQ;QAEpD,uBAAuB;QACvB,IAAI;YACF,MAAM,gIAAE,CAAC,MAAM,CAAC;QAClB,EAAE,OAAM;YACN,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAuB,GAChC;gBAAE,QAAQ;YAAI;QAElB;QAEA,gBAAgB;QAChB,MAAM,aAAa,MAAM,gIAAE,CAAC,QAAQ,CAAC;QAErC,iDAAiD;QACjD,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC,KAAK,QAAQ,EAAE,WAAW;QACnD,IAAI,cAAc;QAClB,IAAI,QAAQ,QAAQ,cAAc;QAClC,IAAI,QAAQ,QAAQ,cAAc;QAClC,IAAI,QAAQ,QAAQ,cAAc;QAElC,iDAAiD;QACjD,OAAO,IAAI,gJAAY,CAAC,YAAY;YAClC,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,kBAAkB,WAAW,MAAM,CAAC,QAAQ;gBAC5C,iBAAiB;gBACjB,iBAAiB;YACnB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA6B,GACtC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}