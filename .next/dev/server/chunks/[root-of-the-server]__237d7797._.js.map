{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/claude-service.ts"],"sourcesContent":["import Anthropic from '@anthropic-ai/sdk';\nimport type { Transcript, Analysis, QAScores } from '@/types';\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\n// Claude Sonnet 4.5 model\nconst MODEL = 'claude-sonnet-4-5-20250929';\n\ninterface ClaudeAnalysisResponse {\n  overallScore: number;\n  scores: QAScores;\n  keyMoments: Array<{\n    timestamp: number;\n    type: 'positive' | 'negative' | 'neutral';\n    category: string;\n    description: string;\n    quote: string;\n  }>;\n  coachingRecommendations: string[];\n  summary: string;\n  callOutcome: string;\n  complianceIssues?: string[];\n}\n\n/**\n * Analyze a transcript using Claude 3.5 Sonnet\n * Evaluates 8 QA dimensions and provides coaching recommendations\n */\nexport async function analyzeTranscript(transcript: Transcript): Promise<Analysis> {\n  const startTime = Date.now();\n\n  try {\n    // Format transcript for Claude\n    const formattedTranscript = formatTranscriptForAnalysis(transcript);\n\n    // Create the analysis prompt\n    const prompt = createAnalysisPrompt(formattedTranscript);\n\n    // Call Claude API\n    const response = await anthropic.messages.create({\n      model: MODEL,\n      max_tokens: 4096,\n      temperature: 0.3, // Lower temperature for more consistent scoring\n      messages: [\n        {\n          role: 'user',\n          content: prompt,\n        },\n      ],\n    });\n\n    // Parse Claude's response\n    const analysisText = response.content[0].type === 'text' ? response.content[0].text : '';\n    const parsedAnalysis = parseClaudeResponse(analysisText);\n\n    const processingTime = Date.now() - startTime;\n\n    // Construct final analysis object\n    // Validate quotes against transcript before returning\n    const validatedKeyMoments = validateQuotes(parsedAnalysis.keyMoments, transcript);\n\n    const analysis: Analysis = {\n      callId: transcript.callId,\n      overallScore: parsedAnalysis.overallScore,\n      scores: parsedAnalysis.scores,\n      keyMoments: validatedKeyMoments,\n      coachingRecommendations: parsedAnalysis.coachingRecommendations,\n      summary: parsedAnalysis.summary,\n      callOutcome: parsedAnalysis.callOutcome,\n      complianceIssues: parsedAnalysis.complianceIssues,\n      processingTime,\n    };\n\n    return analysis;\n  } catch (error) {\n    console.error('Claude analysis error:', error);\n    throw new Error(`Failed to analyze transcript: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Format transcript into a readable format for Claude\n */\nfunction formatTranscriptForAnalysis(transcript: Transcript): string {\n  const lines: string[] = [];\n\n  lines.push(`Call Duration: ${Math.floor(transcript.durationSeconds / 60)}m ${Math.floor(transcript.durationSeconds % 60)}s`);\n  lines.push(`Language: ${transcript.language || 'Unknown'}`);\n  lines.push('');\n  lines.push('TRANSCRIPT:');\n  lines.push('---');\n  lines.push('');\n\n  transcript.turns.forEach((turn) => {\n    const timestamp = formatTimestamp(turn.timestamp);\n    const speaker = turn.speaker === 'agent' ? 'AGENT' : 'CUSTOMER';\n    lines.push(`[${timestamp}] ${speaker}: ${turn.text}`);\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Format timestamp as MM:SS\n */\nfunction formatTimestamp(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Create comprehensive analysis prompt for Claude\n */\nfunction createAnalysisPrompt(formattedTranscript: string): string {\n  return `You are an expert Quality Assurance analyst for customer service and sales calls. Analyze the following call transcript and provide a comprehensive QA evaluation.\n\n${formattedTranscript}\n\nPlease analyze this call across the following 8 dimensions, scoring each from 0-10:\n\n1. **Rapport Building** (rapport): How well did the agent establish connection and trust with the customer?\n   - 8-10: Excellent rapport, warm and personable, builds strong connection\n   - 5-7: Adequate rapport, professional but somewhat distant\n   - 0-4: Poor rapport, cold or impersonal interaction\n\n2. **Needs Discovery** (needsDiscovery): How effectively did the agent identify customer needs and pain points?\n   - 8-10: Thorough discovery, asked probing questions, uncovered key needs\n   - 5-7: Basic discovery, identified some needs but missed opportunities\n   - 0-4: Poor discovery, failed to understand customer needs\n\n3. **Product Knowledge** (productKnowledge): How well did the agent demonstrate understanding of products/services?\n   - 8-10: Expert knowledge, confident explanations, handled complex questions\n   - 5-7: Adequate knowledge, answered most questions correctly\n   - 0-4: Poor knowledge, gave incorrect or incomplete information\n\n4. **Objection Handling** (objectionHandling): How effectively did the agent address concerns and objections?\n   - 8-10: Excellent handling, addressed concerns thoroughly, turned objections into opportunities\n   - 5-7: Adequate handling, addressed concerns but lacked confidence\n   - 0-4: Poor handling, avoided or dismissed objections\n\n5. **Closing Techniques** (closing): How well did the agent move toward a resolution or next step?\n   - 8-10: Strong close, clear next steps, gained commitment\n   - 5-7: Adequate close, some next steps but lacked clarity\n   - 0-4: Weak or no close, left customer uncertain\n\n6. **Compliance** (compliance): Did the agent follow required scripts, disclosures, and legal requirements?\n   - 8-10: Full compliance, all required elements covered\n   - 5-7: Mostly compliant, minor omissions\n   - 0-4: Non-compliant, missed critical requirements\n\n7. **Professionalism** (professionalism): How professional was the agent's communication and demeanor?\n   - 8-10: Highly professional, polished communication, appropriate tone\n   - 5-7: Adequately professional, occasional lapses\n   - 0-4: Unprofessional behavior or communication\n\n8. **Follow-Up** (followUp): How well did the agent set expectations for next steps and follow-up?\n   - 8-10: Clear follow-up plan, documented action items, set expectations\n   - 5-7: Basic follow-up, some next steps mentioned\n   - 0-4: No follow-up plan or unclear next steps\n\nAdditionally, identify:\n- **Key Moments**: 8-12 specific moments spread across ALL 8 dimensions above. Each moment must:\n  - Include the exact dimension category (rapport, needsDiscovery, productKnowledge, objectionHandling, closing, compliance, professionalism, followUp)\n  - Have a precise timestamp in seconds matching the transcript\n  - **CRITICAL**: Include an EXACT, VERBATIM quote copied directly from the transcript - DO NOT paraphrase, summarize, or infer dialogue\n  - The quote must be a direct copy-paste from the transcript text, not a summary or interpretation\n  - If you cannot find an exact quote, skip that moment rather than inventing dialogue\n  - Be marked as positive, negative, or neutral\n  - Provide context for why this moment matters for that dimension\n  - TRY TO INCLUDE AT LEAST ONE MOMENT FOR EACH OF THE 8 DIMENSIONS\n- **Call Outcome**: Brief description of how the call ended (e.g., \"Sale closed\", \"Follow-up scheduled\", \"Customer declined\")\n- **Coaching Recommendations**: 3-5 specific, actionable coaching points for the agent\n- **Compliance Issues**: Any compliance violations or concerns with severity level (minor/moderate/critical), description, and timestamp (empty array if none)\n- **Summary**: 2-3 sentence overall summary of the call\n\nRespond in the following JSON format (and ONLY JSON, no markdown formatting):\n\n{\n  \"overallScore\": 7.5,\n  \"scores\": {\n    \"rapport\": 8,\n    \"needsDiscovery\": 7,\n    \"productKnowledge\": 9,\n    \"objectionHandling\": 6,\n    \"closing\": 7,\n    \"compliance\": 9,\n    \"professionalism\": 8,\n    \"followUp\": 7\n  },\n  \"keyMoments\": [\n    {\n      \"timestamp\": 45,\n      \"type\": \"positive\",\n      \"category\": \"rapport\",\n      \"description\": \"Agent showed empathy for customer's situation\",\n      \"quote\": \"I completely understand how frustrating that must be for you\"\n    }\n  ],\n  \"coachingRecommendations\": [\n    \"Practice more probing questions during needs discovery phase\",\n    \"Work on confidence when handling price objections\"\n  ],\n  \"summary\": \"Agent successfully closed the sale with strong product knowledge. Could improve objection handling and needs discovery.\",\n  \"callOutcome\": \"Sale closed - customer purchased premium package\",\n  \"complianceIssues\": []\n}`;\n}\n\n/**\n * Parse Claude's JSON response into typed analysis object\n */\nfunction parseClaudeResponse(responseText: string): ClaudeAnalysisResponse {\n  try {\n    // Remove markdown code blocks if present\n    let jsonText = responseText.trim();\n    if (jsonText.startsWith('```json')) {\n      jsonText = jsonText.replace(/^```json\\n?/, '').replace(/\\n?```$/, '');\n    } else if (jsonText.startsWith('```')) {\n      jsonText = jsonText.replace(/^```\\n?/, '').replace(/\\n?```$/, '');\n    }\n\n    // Extract JSON from response - find first { and last }\n    const firstBrace = jsonText.indexOf('{');\n    const lastBrace = jsonText.lastIndexOf('}');\n\n    if (firstBrace === -1 || lastBrace === -1) {\n      throw new Error('No JSON object found in response');\n    }\n\n    jsonText = jsonText.substring(firstBrace, lastBrace + 1);\n\n    const parsed = JSON.parse(jsonText);\n\n    // Validate and set defaults\n    const analysis: ClaudeAnalysisResponse = {\n      overallScore: parsed.overallScore || 0,\n      scores: {\n        rapport: parsed.scores?.rapport || 0,\n        needsDiscovery: parsed.scores?.needsDiscovery || 0,\n        productKnowledge: parsed.scores?.productKnowledge || 0,\n        objectionHandling: parsed.scores?.objectionHandling || 0,\n        closing: parsed.scores?.closing || 0,\n        compliance: parsed.scores?.compliance || 0,\n        professionalism: parsed.scores?.professionalism || 0,\n        followUp: parsed.scores?.followUp || 0,\n      },\n      keyMoments: parsed.keyMoments || [],\n      coachingRecommendations: parsed.coachingRecommendations || [],\n      summary: parsed.summary || 'No summary provided',\n      callOutcome: parsed.callOutcome || 'Unknown outcome',\n      complianceIssues: parsed.complianceIssues || [],\n    };\n\n    return analysis;\n  } catch (error) {\n    console.error('Failed to parse Claude response:', error);\n    console.error('Raw response:', responseText);\n    throw new Error('Failed to parse analysis response from Claude');\n  }\n}\n\n/**\n * Validate that quotes in key moments actually exist in the transcript\n * Filters out hallucinated quotes to ensure data reliability\n */\nfunction validateQuotes(keyMoments: any[], transcript: Transcript): any[] {\n  return keyMoments.filter((moment) => {\n    const { timestamp, quote } = moment;\n\n    // Find turns within +/- 30 seconds of the timestamp\n    const relevantTurns = transcript.turns.filter(\n      (turn) => Math.abs(turn.timestamp - timestamp) <= 30\n    );\n\n    // Check if quote exists in any of the relevant turns (fuzzy match)\n    // Extract significant words (length > 3) for matching\n    const quoteWords = quote\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((w: string) => w.length > 3);\n    const minMatchWords = Math.max(3, Math.floor(quoteWords.length * 0.6)); // At least 60% of words should match\n\n    for (const turn of relevantTurns) {\n      const turnWords = turn.text.toLowerCase().split(/\\s+/);\n      let matchedWords = 0;\n\n      for (const word of quoteWords) {\n        if (turnWords.some((tw) => tw.includes(word) || word.includes(tw))) {\n          matchedWords++;\n        }\n      }\n\n      if (matchedWords >= minMatchWords) {\n        return true; // Quote verified\n      }\n    }\n\n    // Quote could not be verified - log and filter out\n    console.warn(\n      `[ANALYSIS VALIDATION] Filtered out potentially hallucinated quote at ${Math.floor(timestamp / 60)}:${Math.floor(timestamp % 60)} - \"${quote.substring(0, 50)}...\"`\n    );\n    return false;\n  });\n}\n\n/**\n * Estimate analysis cost for a transcript\n * @param transcript - Transcript to analyze\n * @returns Estimated cost in USD\n */\nexport function estimateAnalysisCost(transcript: Transcript): number {\n  // Rough estimate: ~1.5 tokens per word\n  const transcriptWords = transcript.turns.reduce(\n    (sum, turn) => sum + turn.text.split(' ').length,\n    0\n  );\n  const promptWords = 800; // Approximate system prompt + instructions\n  const totalWords = transcriptWords + promptWords;\n  const inputTokens = Math.ceil(totalWords * 1.5);\n\n  // Estimated output: ~1000 tokens for comprehensive analysis\n  const outputTokens = 1000;\n\n  // Claude Sonnet 4.5 pricing: $3/MTok input, $15/MTok output\n  const inputCost = (inputTokens / 1_000_000) * 3;\n  const outputCost = (outputTokens / 1_000_000) * 15;\n\n  return inputCost + outputCost;\n}\n\n/**\n * Format analysis as human-readable text\n */\nexport function formatAnalysisAsText(analysis: Analysis): string {\n  const lines: string[] = [];\n\n  lines.push('='.repeat(80));\n  lines.push('QA ANALYSIS REPORT');\n  lines.push('='.repeat(80));\n  lines.push('');\n  lines.push(`Call ID: ${analysis.callId}`);\n  lines.push(`Overall Score: ${analysis.overallScore.toFixed(1)}/10`);\n  lines.push('');\n\n  lines.push('DIMENSIONAL SCORES:');\n  lines.push('-'.repeat(80));\n  Object.entries(analysis.scores).forEach(([dimension, score]) => {\n    const label = dimension.replace(/([A-Z])/g, ' $1').trim();\n    const capitalizedLabel = label.charAt(0).toUpperCase() + label.slice(1);\n    lines.push(`${capitalizedLabel.padEnd(25)} ${score.toFixed(1)}/10`);\n  });\n  lines.push('');\n\n  lines.push('SUMMARY:');\n  lines.push('-'.repeat(80));\n  lines.push(analysis.summary);\n  lines.push('');\n\n  lines.push(`CALL OUTCOME: ${analysis.callOutcome}`);\n  lines.push('');\n\n  if (analysis.keyMoments.length > 0) {\n    lines.push('KEY MOMENTS:');\n    lines.push('-'.repeat(80));\n    analysis.keyMoments.forEach((moment, idx) => {\n      const timestamp = formatTimestamp(moment.timestamp);\n      const typeEmoji = moment.type === 'positive' ? '✅' : moment.type === 'negative' ? '❌' : '➖';\n      lines.push(`${idx + 1}. [${timestamp}] ${typeEmoji} ${moment.category.toUpperCase()}`);\n      lines.push(`   ${moment.description}`);\n      lines.push(`   \"${moment.quote}\"`);\n      lines.push('');\n    });\n  }\n\n  if (analysis.coachingRecommendations.length > 0) {\n    lines.push('COACHING RECOMMENDATIONS:');\n    lines.push('-'.repeat(80));\n    analysis.coachingRecommendations.forEach((rec, idx) => {\n      lines.push(`${idx + 1}. ${rec}`);\n    });\n    lines.push('');\n  }\n\n  if (analysis.complianceIssues && analysis.complianceIssues.length > 0) {\n    lines.push('⚠️  COMPLIANCE ISSUES:');\n    lines.push('-'.repeat(80));\n    analysis.complianceIssues.forEach((issue, idx) => {\n      lines.push(`${idx + 1}. ${issue}`);\n    });\n    lines.push('');\n  }\n\n  lines.push(`Processing Time: ${Math.floor(analysis.processingTime! / 1000)}s`);\n\n  return lines.join('\\n');\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/storage.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport type { Call, Transcript } from '@/types';\n\nconst DATA_DIR = path.join(process.cwd(), 'data');\nconst CALLS_FILE = path.join(DATA_DIR, 'calls', 'calls.json');\nconst UPLOADS_DIR = path.join(DATA_DIR, 'uploads');\nconst TRANSCRIPTS_DIR = path.join(DATA_DIR, 'transcripts');\nconst ANALYSES_DIR = path.join(DATA_DIR, 'analyses');\n\n/**\n * Ensure required directories exist\n */\nexport async function ensureDirectories() {\n  await fs.mkdir(path.join(DATA_DIR, 'calls'), { recursive: true });\n  await fs.mkdir(UPLOADS_DIR, { recursive: true });\n  await fs.mkdir(TRANSCRIPTS_DIR, { recursive: true });\n  await fs.mkdir(ANALYSES_DIR, { recursive: true });\n}\n\n/**\n * Read all calls from JSON storage\n */\nexport async function readCalls(): Promise<Call[]> {\n  try {\n    const data = await fs.readFile(CALLS_FILE, 'utf-8');\n    const calls = JSON.parse(data);\n\n    // Remove duplicates based on ID (keep first occurrence)\n    const seen = new Set<string>();\n    const uniqueCalls = calls.filter((call: Call) => {\n      if (seen.has(call.id)) {\n        return false;\n      }\n      seen.add(call.id);\n      return true;\n    });\n\n    // If duplicates were found, write the deduplicated list back\n    if (uniqueCalls.length !== calls.length) {\n      console.log(`Removed ${calls.length - uniqueCalls.length} duplicate call(s)`);\n      await writeCalls(uniqueCalls);\n    }\n\n    // Sort by updatedAt descending (most recent first)\n    const sortedCalls = uniqueCalls.sort((a, b) => {\n      const dateA = new Date(a.updatedAt).getTime();\n      const dateB = new Date(b.updatedAt).getTime();\n      return dateB - dateA; // Descending order\n    });\n\n    return sortedCalls;\n  } catch (error) {\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n// Mutex lock for preventing concurrent writes\nlet writeQueue: Promise<void> = Promise.resolve();\n\n/**\n * Write calls to JSON storage with mutex lock to prevent corruption\n */\nexport async function writeCalls(calls: Call[]): Promise<void> {\n  // Wait for any pending writes to complete\n  await writeQueue;\n\n  // Queue this write operation\n  writeQueue = (async () => {\n    try {\n      await ensureDirectories();\n      await fs.writeFile(CALLS_FILE, JSON.stringify(calls, null, 2), 'utf-8');\n    } catch (error) {\n      console.error('[STORAGE] Failed to write calls:', error);\n      throw error;\n    }\n  })();\n\n  await writeQueue;\n}\n\n/**\n * Add a new call record\n */\nexport async function addCall(call: Call): Promise<Call> {\n  const calls = await readCalls();\n\n  // Check if call already exists\n  const existingIndex = calls.findIndex((c) => c.id === call.id);\n  if (existingIndex !== -1) {\n    // Update existing call instead of adding duplicate\n    calls[existingIndex] = call;\n  } else {\n    calls.push(call);\n  }\n\n  await writeCalls(calls);\n  return call;\n}\n\n/**\n * Get call by ID\n */\nexport async function getCallById(id: string): Promise<Call | null> {\n  const calls = await readCalls();\n  return calls.find((call) => call.id === id) || null;\n}\n\n/**\n * Update call record\n */\nexport async function updateCall(id: string, updates: Partial<Call>): Promise<Call | null> {\n  const calls = await readCalls();\n  const index = calls.findIndex((call) => call.id === id);\n\n  if (index === -1) {\n    return null;\n  }\n\n  calls[index] = {\n    ...calls[index],\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await writeCalls(calls);\n  return calls[index];\n}\n\n/**\n * Save uploaded file\n */\nexport async function saveUploadedFile(\n  buffer: Buffer,\n  filename: string\n): Promise<string> {\n  await ensureDirectories();\n  const filepath = path.join(UPLOADS_DIR, filename);\n  await fs.writeFile(filepath, buffer);\n  return filepath;\n}\n\n/**\n * Get upload path for a file\n */\nexport function getUploadPath(filename: string): string {\n  return path.join(UPLOADS_DIR, filename);\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filename: string): Promise<boolean> {\n  try {\n    await fs.access(getUploadPath(filename));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate unique call ID\n */\nexport function generateCallId(): string {\n  return `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Save transcript to JSON file\n */\nexport async function saveTranscript(transcript: Transcript): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(TRANSCRIPTS_DIR, `${transcript.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(transcript, null, 2), 'utf-8');\n}\n\n/**\n * Save transcript as plain text\n */\nexport async function saveTranscriptAsText(callId: string, textContent: string): Promise<void> {\n  await ensureDirectories();\n  const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n  await fs.writeFile(txtPath, textContent, 'utf-8');\n}\n\n/**\n * Get transcript by call ID\n */\nexport async function getTranscript(callId: string): Promise<Transcript | null> {\n  try {\n    const jsonPath = path.join(TRANSCRIPTS_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get transcript text by call ID\n */\nexport async function getTranscriptText(callId: string): Promise<string | null> {\n  try {\n    const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n    return await fs.readFile(txtPath, 'utf-8');\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Save analysis to JSON file\n */\nexport async function saveAnalysis(analysis: any): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(ANALYSES_DIR, `${analysis.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(analysis, null, 2), 'utf-8');\n}\n\n/**\n * Get analysis by call ID\n */\nexport async function getAnalysis(callId: string): Promise<any | null> {\n  try {\n    const jsonPath = path.join(ANALYSES_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get complete call data (call + transcript + analysis)\n */\nexport async function getCompleteCallData(callId: string): Promise<{\n  call: Call | null;\n  transcript: Transcript | null;\n  analysis: any | null;\n}> {\n  const [call, transcript, analysis] = await Promise.all([\n    getCallById(callId),\n    getTranscript(callId),\n    getAnalysis(callId),\n  ]);\n\n  return { call, transcript, analysis };\n}\n\n/**\n * Delete call and all associated data\n */\nexport async function deleteCall(callId: string): Promise<boolean> {\n  try {\n    // Remove from calls.json\n    const calls = await readCalls();\n    const filtered = calls.filter((call) => call.id !== callId);\n    await writeCalls(filtered);\n\n    // Delete transcript files\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.json`));\n    } catch {}\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.txt`));\n    } catch {}\n\n    // Delete analysis file\n    try {\n      await fs.unlink(path.join(ANALYSES_DIR, `${callId}.json`));\n    } catch {}\n\n    // Delete uploaded audio file (if exists)\n    const call = await getCallById(callId);\n    if (call?.filename) {\n      try {\n        await fs.unlink(getUploadPath(call.filename));\n      } catch {}\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting call:', error);\n    return false;\n  }\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalCalls: number;\n  uploadedCalls: number;\n  transcribedCalls: number;\n  analyzedCalls: number;\n  errorCalls: number;\n  totalStorageBytes: number;\n}> {\n  const calls = await readCalls();\n\n  const stats = {\n    totalCalls: calls.length,\n    uploadedCalls: calls.filter((c) => c.status === 'pending').length,\n    transcribedCalls: calls.filter((c) => c.status === 'analyzing' || c.status === 'complete').length,\n    analyzedCalls: calls.filter((c) => c.status === 'complete').length,\n    errorCalls: calls.filter((c) => c.status === 'error').length,\n    totalStorageBytes: 0,\n  };\n\n  // Calculate total storage size\n  try {\n    const transcriptFiles = await fs.readdir(TRANSCRIPTS_DIR);\n    const analysisFiles = await fs.readdir(ANALYSES_DIR);\n    const uploadFiles = await fs.readdir(UPLOADS_DIR);\n\n    for (const file of transcriptFiles) {\n      const stat = await fs.stat(path.join(TRANSCRIPTS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of analysisFiles) {\n      const stat = await fs.stat(path.join(ANALYSES_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of uploadFiles) {\n      const stat = await fs.stat(path.join(UPLOADS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n  } catch (error) {\n    console.error('Error calculating storage size:', error);\n  }\n\n  return stats;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 674, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/app/api/analyze/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { analyzeTranscript, estimateAnalysisCost } from '@/lib/claude-service';\nimport { saveAnalysis, updateCall, getTranscript } from '@/lib/storage';\nimport type { Transcript, AnalysisResponse, ApiResponse } from '@/types';\n\n/**\n * POST /api/analyze\n * Analyze a transcript using Claude AI\n *\n * Request body:\n * {\n *   \"callId\": string (to load transcript from storage)\n *   OR\n *   \"transcript\": Transcript object (from /api/transcribe)\n * }\n *\n * Response:\n * {\n *   \"analysis\": Analysis object with scores and recommendations\n *   \"estimatedCost\": number (USD)\n * }\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Validate API key is configured\n    if (!process.env.ANTHROPIC_API_KEY) {\n      return NextResponse.json(\n        { error: 'ANTHROPIC_API_KEY not configured' },\n        { status: 500 }\n      );\n    }\n\n    // Parse request body\n    const body = await request.json();\n    let transcript: Transcript;\n\n    // Support both callId and direct transcript\n    if (body.callId) {\n      const storedTranscript = await getTranscript(body.callId);\n      if (!storedTranscript) {\n        return NextResponse.json(\n          { error: 'Transcript not found for this call' },\n          { status: 404 }\n        );\n      }\n      transcript = storedTranscript;\n    } else if (body.transcript) {\n      transcript = body.transcript;\n    } else {\n      return NextResponse.json(\n        { error: 'Either callId or transcript is required' },\n        { status: 400 }\n      );\n    }\n\n    // Validate transcript\n    if (!transcript || !transcript.callId || !Array.isArray(transcript.turns)) {\n      return NextResponse.json(\n        { error: 'Invalid transcript format' },\n        { status: 400 }\n      );\n    }\n\n    if (transcript.turns.length === 0) {\n      return NextResponse.json(\n        { error: 'Transcript is empty' },\n        { status: 400 }\n      );\n    }\n\n    // Estimate cost before analysis\n    const estimatedCost = estimateAnalysisCost(transcript);\n\n    console.log(`Analyzing transcript ${transcript.callId} (estimated cost: $${estimatedCost.toFixed(4)})`);\n\n    // Perform analysis\n    const analysis = await analyzeTranscript(transcript);\n\n    // Save analysis to storage\n    await saveAnalysis(analysis);\n\n    // Update call status to complete\n    await updateCall(transcript.callId, {\n      status: 'complete',\n      overallScore: analysis.overallScore,\n      analysisUrl: `/data/analyses/${transcript.callId}.json`,\n    });\n\n    // Return analysis results\n    const response: AnalysisResponse & { estimatedCost: number } = {\n      analysis,\n      estimatedCost,\n    };\n\n    return NextResponse.json(response, { status: 200 });\n\n  } catch (error) {\n    console.error('Analysis API error:', error);\n\n    // Try to update call status to error\n    try {\n      const body = await request.json();\n      const callId = body.callId || body.transcript?.callId;\n      if (callId) {\n        await updateCall(callId, {\n          status: 'error',\n          errorMessage: (error as Error).message,\n        });\n      }\n    } catch {}\n\n    return NextResponse.json(\n      {\n        error: 'Failed to analyze transcript',\n        details: (error as Error).message\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/analyze\n * Get API status\n */\nexport async function GET() {\n  const isConfigured = !!process.env.ANTHROPIC_API_KEY;\n\n  return NextResponse.json({\n    status: 'ok',\n    service: 'Claude QA Analysis API',\n    model: 'claude-sonnet-4.5-20250929',\n    configured: isConfigured,\n  });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAoBO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,iCAAiC;QACjC,IAAI,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAE;YAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,IAAI;QAEJ,4CAA4C;QAC5C,IAAI,KAAK,MAAM,EAAE;YACf,MAAM,mBAAmB,MAAM,IAAA,wIAAa,EAAC,KAAK,MAAM;YACxD,IAAI,CAAC,kBAAkB;gBACrB,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAAqC,GAC9C;oBAAE,QAAQ;gBAAI;YAElB;YACA,aAAa;QACf,OAAO,IAAI,KAAK,UAAU,EAAE;YAC1B,aAAa,KAAK,UAAU;QAC9B,OAAO;YACL,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0C,GACnD;gBAAE,QAAQ;YAAI;QAElB;QAEA,sBAAsB;QACtB,IAAI,CAAC,cAAc,CAAC,WAAW,MAAM,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW,KAAK,GAAG;YACzE,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,WAAW,KAAK,CAAC,MAAM,KAAK,GAAG;YACjC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsB,GAC/B;gBAAE,QAAQ;YAAI;QAElB;QAEA,gCAAgC;QAChC,MAAM,gBAAgB,IAAA,yJAAoB,EAAC;QAE3C,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,WAAW,MAAM,CAAC,mBAAmB,EAAE,cAAc,OAAO,CAAC,GAAG,CAAC,CAAC;QAEtG,mBAAmB;QACnB,MAAM,WAAW,MAAM,IAAA,sJAAiB,EAAC;QAEzC,2BAA2B;QAC3B,MAAM,IAAA,uIAAY,EAAC;QAEnB,iCAAiC;QACjC,MAAM,IAAA,qIAAU,EAAC,WAAW,MAAM,EAAE;YAClC,QAAQ;YACR,cAAc,SAAS,YAAY;YACnC,aAAa,CAAC,eAAe,EAAE,WAAW,MAAM,CAAC,KAAK,CAAC;QACzD;QAEA,0BAA0B;QAC1B,MAAM,WAAyD;YAC7D;YACA;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,UAAU;YAAE,QAAQ;QAAI;IAEnD,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QAErC,qCAAqC;QACrC,IAAI;YACF,MAAM,OAAO,MAAM,QAAQ,IAAI;YAC/B,MAAM,SAAS,KAAK,MAAM,IAAI,KAAK,UAAU,EAAE;YAC/C,IAAI,QAAQ;gBACV,MAAM,IAAA,qIAAU,EAAC,QAAQ;oBACvB,QAAQ;oBACR,cAAc,AAAC,MAAgB,OAAO;gBACxC;YACF;QACF,EAAE,OAAM,CAAC;QAET,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,AAAC,MAAgB,OAAO;QACnC,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAMO,eAAe;IACpB,MAAM,eAAe,CAAC,CAAC,QAAQ,GAAG,CAAC,iBAAiB;IAEpD,OAAO,gJAAY,CAAC,IAAI,CAAC;QACvB,QAAQ;QACR,SAAS;QACT,OAAO;QACP,YAAY;IACd;AACF","debugId":null}}]
}