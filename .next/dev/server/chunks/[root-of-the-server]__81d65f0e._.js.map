{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/storage.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport type { Call, Transcript } from '@/types';\n\nconst DATA_DIR = path.join(process.cwd(), 'data');\nconst CALLS_FILE = path.join(DATA_DIR, 'calls', 'calls.json');\nconst UPLOADS_DIR = path.join(DATA_DIR, 'uploads');\nconst TRANSCRIPTS_DIR = path.join(DATA_DIR, 'transcripts');\nconst ANALYSES_DIR = path.join(DATA_DIR, 'analyses');\n\n/**\n * Ensure required directories exist\n */\nexport async function ensureDirectories() {\n  await fs.mkdir(path.join(DATA_DIR, 'calls'), { recursive: true });\n  await fs.mkdir(UPLOADS_DIR, { recursive: true });\n  await fs.mkdir(TRANSCRIPTS_DIR, { recursive: true });\n  await fs.mkdir(ANALYSES_DIR, { recursive: true });\n}\n\n/**\n * Read all calls from JSON storage\n */\nexport async function readCalls(): Promise<Call[]> {\n  try {\n    const data = await fs.readFile(CALLS_FILE, 'utf-8');\n    const calls = JSON.parse(data);\n\n    // Remove duplicates based on ID (keep first occurrence)\n    const seen = new Set<string>();\n    const uniqueCalls = calls.filter((call: Call) => {\n      if (seen.has(call.id)) {\n        return false;\n      }\n      seen.add(call.id);\n      return true;\n    });\n\n    // If duplicates were found, write the deduplicated list back\n    if (uniqueCalls.length !== calls.length) {\n      console.log(`Removed ${calls.length - uniqueCalls.length} duplicate call(s)`);\n      await writeCalls(uniqueCalls);\n    }\n\n    // Sort by updatedAt descending (most recent first)\n    const sortedCalls = uniqueCalls.sort((a, b) => {\n      const dateA = new Date(a.updatedAt).getTime();\n      const dateB = new Date(b.updatedAt).getTime();\n      return dateB - dateA; // Descending order\n    });\n\n    return sortedCalls;\n  } catch (error) {\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n// Mutex lock for preventing concurrent writes\nlet writeQueue: Promise<void> = Promise.resolve();\n\n/**\n * Write calls to JSON storage with mutex lock to prevent corruption\n */\nexport async function writeCalls(calls: Call[]): Promise<void> {\n  // Wait for any pending writes to complete\n  await writeQueue;\n\n  // Queue this write operation\n  writeQueue = (async () => {\n    try {\n      await ensureDirectories();\n      await fs.writeFile(CALLS_FILE, JSON.stringify(calls, null, 2), 'utf-8');\n    } catch (error) {\n      console.error('[STORAGE] Failed to write calls:', error);\n      throw error;\n    }\n  })();\n\n  await writeQueue;\n}\n\n/**\n * Add a new call record\n */\nexport async function addCall(call: Call): Promise<Call> {\n  const calls = await readCalls();\n\n  // Check if call already exists\n  const existingIndex = calls.findIndex((c) => c.id === call.id);\n  if (existingIndex !== -1) {\n    // Update existing call instead of adding duplicate\n    calls[existingIndex] = call;\n  } else {\n    calls.push(call);\n  }\n\n  await writeCalls(calls);\n  return call;\n}\n\n/**\n * Get call by ID\n */\nexport async function getCallById(id: string): Promise<Call | null> {\n  const calls = await readCalls();\n  return calls.find((call) => call.id === id) || null;\n}\n\n/**\n * Update call record\n */\nexport async function updateCall(id: string, updates: Partial<Call>): Promise<Call | null> {\n  const calls = await readCalls();\n  const index = calls.findIndex((call) => call.id === id);\n\n  if (index === -1) {\n    return null;\n  }\n\n  calls[index] = {\n    ...calls[index],\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await writeCalls(calls);\n  return calls[index];\n}\n\n/**\n * Save uploaded file\n */\nexport async function saveUploadedFile(\n  buffer: Buffer,\n  filename: string\n): Promise<string> {\n  await ensureDirectories();\n  const filepath = path.join(UPLOADS_DIR, filename);\n  await fs.writeFile(filepath, buffer);\n  return filepath;\n}\n\n/**\n * Get upload path for a file\n */\nexport function getUploadPath(filename: string): string {\n  return path.join(UPLOADS_DIR, filename);\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filename: string): Promise<boolean> {\n  try {\n    await fs.access(getUploadPath(filename));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate unique call ID\n */\nexport function generateCallId(): string {\n  return `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Save transcript to JSON file\n */\nexport async function saveTranscript(transcript: Transcript): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(TRANSCRIPTS_DIR, `${transcript.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(transcript, null, 2), 'utf-8');\n}\n\n/**\n * Save transcript as plain text\n */\nexport async function saveTranscriptAsText(callId: string, textContent: string): Promise<void> {\n  await ensureDirectories();\n  const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n  await fs.writeFile(txtPath, textContent, 'utf-8');\n}\n\n/**\n * Get transcript by call ID\n */\nexport async function getTranscript(callId: string): Promise<Transcript | null> {\n  try {\n    const jsonPath = path.join(TRANSCRIPTS_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get transcript text by call ID\n */\nexport async function getTranscriptText(callId: string): Promise<string | null> {\n  try {\n    const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n    return await fs.readFile(txtPath, 'utf-8');\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Save analysis to JSON file\n */\nexport async function saveAnalysis(analysis: any): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(ANALYSES_DIR, `${analysis.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(analysis, null, 2), 'utf-8');\n}\n\n/**\n * Get analysis by call ID\n */\nexport async function getAnalysis(callId: string): Promise<any | null> {\n  try {\n    const jsonPath = path.join(ANALYSES_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get complete call data (call + transcript + analysis)\n */\nexport async function getCompleteCallData(callId: string): Promise<{\n  call: Call | null;\n  transcript: Transcript | null;\n  analysis: any | null;\n}> {\n  const [call, transcript, analysis] = await Promise.all([\n    getCallById(callId),\n    getTranscript(callId),\n    getAnalysis(callId),\n  ]);\n\n  return { call, transcript, analysis };\n}\n\n/**\n * Delete call and all associated data\n */\nexport async function deleteCall(callId: string): Promise<boolean> {\n  try {\n    // Remove from calls.json\n    const calls = await readCalls();\n    const filtered = calls.filter((call) => call.id !== callId);\n    await writeCalls(filtered);\n\n    // Delete transcript files\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.json`));\n    } catch {}\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.txt`));\n    } catch {}\n\n    // Delete analysis file\n    try {\n      await fs.unlink(path.join(ANALYSES_DIR, `${callId}.json`));\n    } catch {}\n\n    // Delete uploaded audio file (if exists)\n    const call = await getCallById(callId);\n    if (call?.filename) {\n      try {\n        await fs.unlink(getUploadPath(call.filename));\n      } catch {}\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting call:', error);\n    return false;\n  }\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalCalls: number;\n  uploadedCalls: number;\n  transcribedCalls: number;\n  analyzedCalls: number;\n  errorCalls: number;\n  totalStorageBytes: number;\n}> {\n  const calls = await readCalls();\n\n  const stats = {\n    totalCalls: calls.length,\n    uploadedCalls: calls.filter((c) => c.status === 'pending').length,\n    transcribedCalls: calls.filter((c) => c.status === 'analyzing' || c.status === 'complete').length,\n    analyzedCalls: calls.filter((c) => c.status === 'complete').length,\n    errorCalls: calls.filter((c) => c.status === 'error').length,\n    totalStorageBytes: 0,\n  };\n\n  // Calculate total storage size\n  try {\n    const transcriptFiles = await fs.readdir(TRANSCRIPTS_DIR);\n    const analysisFiles = await fs.readdir(ANALYSES_DIR);\n    const uploadFiles = await fs.readdir(UPLOADS_DIR);\n\n    for (const file of transcriptFiles) {\n      const stat = await fs.stat(path.join(TRANSCRIPTS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of analysisFiles) {\n      const stat = await fs.stat(path.join(ANALYSES_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of uploadFiles) {\n      const stat = await fs.stat(path.join(UPLOADS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n  } catch (error) {\n    console.error('Error calculating storage size:', error);\n  }\n\n  return stats;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/lib/whisper-service.ts"],"sourcesContent":["import OpenAI from 'openai';\nimport fs from 'fs/promises';\nimport type { Transcript, TranscriptTurn } from '@/types';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport interface WhisperResponse {\n  text: string;\n  segments?: Array<{\n    id: number;\n    seek: number;\n    start: number;\n    end: number;\n    text: string;\n    tokens: number[];\n    temperature: number;\n    avg_logprob: number;\n    compression_ratio: number;\n    no_speech_prob: number;\n  }>;\n  language?: string;\n  duration?: number;\n}\n\n/**\n * Transcribe audio file using OpenAI Whisper API\n * @param filePath - Path to the audio file\n * @returns Transcript object with speaker diarization\n */\nexport async function transcribeAudio(filePath: string, callId: string): Promise<Transcript> {\n  const startTime = Date.now();\n\n  try {\n    // Read the audio file\n    const fileBuffer = await fs.readFile(filePath);\n    const file = new File([fileBuffer], filePath.split('/').pop() || 'audio.wav', {\n      type: 'audio/wav',\n    });\n\n    // Call OpenAI Whisper API with verbose_json to get timestamps\n    // Force English language to prevent misdetection (e.g., Welsh instead of English)\n    const response = await openai.audio.transcriptions.create({\n      file: file,\n      model: 'whisper-1',\n      response_format: 'verbose_json',\n      timestamp_granularities: ['segment'],\n      language: 'en', // Force English transcription\n    });\n\n    const processingTime = Date.now() - startTime;\n\n    // Parse response and create transcript turns\n    const turns: TranscriptTurn[] = [];\n\n    if (response.segments && Array.isArray(response.segments)) {\n      // Simple speaker diarization heuristic:\n      // - Alternating speakers based on pauses\n      // - First speaker is assumed to be agent\n      let currentSpeaker: 'agent' | 'customer' = 'agent';\n      let lastEndTime = 0;\n\n      response.segments.forEach((segment: any) => {\n        // If there's a significant pause (>2 seconds), assume speaker change\n        const pause = segment.start - lastEndTime;\n        if (pause > 2 && lastEndTime > 0) {\n          currentSpeaker = currentSpeaker === 'agent' ? 'customer' : 'agent';\n        }\n\n        turns.push({\n          speaker: currentSpeaker,\n          text: segment.text.trim(),\n          timestamp: segment.start,\n          confidence: 1 - (segment.no_speech_prob || 0),\n        });\n\n        lastEndTime = segment.end;\n      });\n    } else {\n      // Fallback: single turn with full text\n      turns.push({\n        speaker: 'agent',\n        text: response.text,\n        timestamp: 0,\n        confidence: 1,\n      });\n    }\n\n    const transcript: Transcript = {\n      callId,\n      turns,\n      durationSeconds: response.duration || 0,\n      language: response.language,\n      processingTime,\n    };\n\n    return transcript;\n  } catch (error) {\n    console.error('Whisper transcription error:', error);\n    throw new Error(`Failed to transcribe audio: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Estimate transcription cost\n * @param durationSeconds - Audio duration in seconds\n * @returns Cost in USD\n */\nexport function estimateTranscriptionCost(durationSeconds: number): number {\n  const hours = durationSeconds / 3600;\n  const costPerHour = 0.36; // $0.36 per hour\n  return hours * costPerHour;\n}\n\n/**\n * Format transcript as plain text for human reading\n * @param transcript - Transcript object\n * @returns Formatted text\n */\nexport function formatTranscriptAsText(transcript: Transcript): string {\n  const lines: string[] = [];\n\n  lines.push('='.repeat(80));\n  lines.push('CALL TRANSCRIPT');\n  lines.push('='.repeat(80));\n  lines.push('');\n  lines.push(`Call ID: ${transcript.callId}`);\n  lines.push(`Duration: ${Math.floor(transcript.durationSeconds / 60)}m ${Math.floor(transcript.durationSeconds % 60)}s`);\n  lines.push(`Language: ${transcript.language || 'Unknown'}`);\n  lines.push(`Processing Time: ${Math.floor(transcript.processingTime! / 1000)}s`);\n  lines.push('');\n  lines.push('='.repeat(80));\n  lines.push('');\n\n  transcript.turns.forEach((turn, index) => {\n    const timestamp = formatTimestamp(turn.timestamp);\n    const speaker = turn.speaker === 'agent' ? 'AGENT' : 'CUSTOMER';\n    const confidence = Math.round((turn.confidence || 0) * 100);\n\n    lines.push(`[${timestamp}] ${speaker} (${confidence}% confidence)`);\n    lines.push(turn.text);\n    lines.push('');\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Format timestamp as MM:SS\n */\nfunction formatTimestamp(seconds: number): string {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"sources":["file:///Users/iamjohndass/Sites/pikl-qa-assist/src/app/api/transcribe/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getCallById, updateCall, getUploadPath, saveTranscript, saveTranscriptAsText } from '@/lib/storage';\nimport { transcribeAudio, formatTranscriptAsText, estimateTranscriptionCost } from '@/lib/whisper-service';\nimport type { ApiResponse, Transcript } from '@/types';\n\n/**\n * POST /api/transcribe\n * Transcribe a specific call by ID\n */\nexport async function POST(req: NextRequest) {\n  try {\n    const body = await req.json();\n    const { callId } = body;\n\n    if (!callId) {\n      return NextResponse.json<ApiResponse<null>>(\n        {\n          success: false,\n          error: 'Call ID is required',\n        },\n        { status: 400 }\n      );\n    }\n\n    // Get call record\n    const call = await getCallById(callId);\n    if (!call) {\n      return NextResponse.json<ApiResponse<null>>(\n        {\n          success: false,\n          error: 'Call not found',\n        },\n        { status: 404 }\n      );\n    }\n\n    // Check if already transcribed\n    if (call.status === 'analyzing' || call.status === 'complete') {\n      return NextResponse.json<ApiResponse<null>>(\n        {\n          success: false,\n          error: 'Call already transcribed',\n        },\n        { status: 400 }\n      );\n    }\n\n    // Update status to transcribing\n    await updateCall(callId, { status: 'transcribing' });\n\n    // Get audio file path\n    const audioPath = getUploadPath(call.filename);\n\n    // Log file information before sending to Whisper\n    const fs = await import('fs/promises');\n    try {\n      const fileStats = await fs.stat(audioPath);\n      const fileSizeMB = (fileStats.size / 1024 / 1024).toFixed(2);\n      console.log(`[TRANSCRIBE] Preparing to send file to Whisper API:`);\n      console.log(`[TRANSCRIBE]   Call ID: ${callId}`);\n      console.log(`[TRANSCRIBE]   Filename: ${call.filename}`);\n      console.log(`[TRANSCRIBE]   Path: ${audioPath}`);\n      console.log(`[TRANSCRIBE]   Size: ${fileSizeMB}MB (${fileStats.size} bytes)`);\n      console.log(`[TRANSCRIBE]   Whisper limit: 25MB (${25 * 1024 * 1024} bytes)`);\n\n      if (fileStats.size > 25 * 1024 * 1024) {\n        console.warn(`[TRANSCRIBE] ⚠ WARNING: File exceeds 25MB Whisper API limit!`);\n      } else {\n        console.log(`[TRANSCRIBE] ✓ File is under Whisper API limit`);\n      }\n    } catch (statError) {\n      console.error(`[TRANSCRIBE] Failed to stat file:`, statError);\n    }\n\n    try {\n      // Transcribe audio\n      const transcript = await transcribeAudio(audioPath, callId);\n\n      // Save transcript as JSON\n      await saveTranscript(transcript);\n\n      // Save transcript as plain text\n      const textContent = formatTranscriptAsText(transcript);\n      await saveTranscriptAsText(callId, textContent);\n\n      // Estimate cost\n      const cost = estimateTranscriptionCost(transcript.durationSeconds);\n\n      // Update call record\n      await updateCall(callId, {\n        status: 'analyzing', // Ready for analysis\n        duration: transcript.durationSeconds,\n        transcriptUrl: `/data/transcripts/${callId}.json`,\n      });\n\n      // Trigger analysis asynchronously (don't wait)\n      fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/analyze`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ callId }),\n      }).catch((err) => console.error('Failed to trigger analysis:', err));\n\n      return NextResponse.json<ApiResponse<{ transcript: Transcript; cost: number }>>(\n        {\n          success: true,\n          data: {\n            transcript,\n            cost,\n          },\n          message: `Successfully transcribed call in ${Math.floor(transcript.processingTime! / 1000)}s. Cost: $${cost.toFixed(4)}`,\n        },\n        { status: 200 }\n      );\n    } catch (transcribeError) {\n      // Update call status to error\n      await updateCall(callId, {\n        status: 'error',\n        errorMessage: (transcribeError as Error).message,\n      });\n\n      throw transcribeError;\n    }\n  } catch (error) {\n    console.error('Transcription error:', error);\n    return NextResponse.json<ApiResponse<null>>(\n      {\n        success: false,\n        error: 'Failed to transcribe audio',\n        message: (error as Error).message,\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}