{"version":3,"sources":["turbopack:///[project]/src/lib/storage.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport type { Call, Transcript } from '@/types';\n\nconst DATA_DIR = path.join(process.cwd(), 'data');\nconst CALLS_FILE = path.join(DATA_DIR, 'calls', 'calls.json');\nconst UPLOADS_DIR = path.join(DATA_DIR, 'uploads');\nconst TRANSCRIPTS_DIR = path.join(DATA_DIR, 'transcripts');\nconst ANALYSES_DIR = path.join(DATA_DIR, 'analyses');\n\n/**\n * Ensure required directories exist\n */\nexport async function ensureDirectories() {\n  await fs.mkdir(path.join(DATA_DIR, 'calls'), { recursive: true });\n  await fs.mkdir(UPLOADS_DIR, { recursive: true });\n  await fs.mkdir(TRANSCRIPTS_DIR, { recursive: true });\n  await fs.mkdir(ANALYSES_DIR, { recursive: true });\n}\n\n/**\n * Read all calls from JSON storage\n */\nexport async function readCalls(): Promise<Call[]> {\n  try {\n    const data = await fs.readFile(CALLS_FILE, 'utf-8');\n    const calls = JSON.parse(data);\n\n    // Remove duplicates based on ID (keep first occurrence)\n    const seen = new Set<string>();\n    const uniqueCalls = calls.filter((call: Call) => {\n      if (seen.has(call.id)) {\n        return false;\n      }\n      seen.add(call.id);\n      return true;\n    });\n\n    // If duplicates were found, write the deduplicated list back\n    if (uniqueCalls.length !== calls.length) {\n      console.log(`Removed ${calls.length - uniqueCalls.length} duplicate call(s)`);\n      await writeCalls(uniqueCalls);\n    }\n\n    return uniqueCalls;\n  } catch (error) {\n    // If file doesn't exist, return empty array\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return [];\n    }\n    throw error;\n  }\n}\n\n/**\n * Write calls to JSON storage\n */\nexport async function writeCalls(calls: Call[]): Promise<void> {\n  await ensureDirectories();\n  await fs.writeFile(CALLS_FILE, JSON.stringify(calls, null, 2), 'utf-8');\n}\n\n/**\n * Add a new call record\n */\nexport async function addCall(call: Call): Promise<Call> {\n  const calls = await readCalls();\n\n  // Check if call already exists\n  const existingIndex = calls.findIndex((c) => c.id === call.id);\n  if (existingIndex !== -1) {\n    // Update existing call instead of adding duplicate\n    calls[existingIndex] = call;\n  } else {\n    calls.push(call);\n  }\n\n  await writeCalls(calls);\n  return call;\n}\n\n/**\n * Get call by ID\n */\nexport async function getCallById(id: string): Promise<Call | null> {\n  const calls = await readCalls();\n  return calls.find((call) => call.id === id) || null;\n}\n\n/**\n * Update call record\n */\nexport async function updateCall(id: string, updates: Partial<Call>): Promise<Call | null> {\n  const calls = await readCalls();\n  const index = calls.findIndex((call) => call.id === id);\n\n  if (index === -1) {\n    return null;\n  }\n\n  calls[index] = {\n    ...calls[index],\n    ...updates,\n    updatedAt: new Date(),\n  };\n\n  await writeCalls(calls);\n  return calls[index];\n}\n\n/**\n * Save uploaded file\n */\nexport async function saveUploadedFile(\n  buffer: Buffer,\n  filename: string\n): Promise<string> {\n  await ensureDirectories();\n  const filepath = path.join(UPLOADS_DIR, filename);\n  await fs.writeFile(filepath, buffer);\n  return filepath;\n}\n\n/**\n * Get upload path for a file\n */\nexport function getUploadPath(filename: string): string {\n  return path.join(UPLOADS_DIR, filename);\n}\n\n/**\n * Check if file exists\n */\nexport async function fileExists(filename: string): Promise<boolean> {\n  try {\n    await fs.access(getUploadPath(filename));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate unique call ID\n */\nexport function generateCallId(): string {\n  return `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\n/**\n * Save transcript to JSON file\n */\nexport async function saveTranscript(transcript: Transcript): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(TRANSCRIPTS_DIR, `${transcript.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(transcript, null, 2), 'utf-8');\n}\n\n/**\n * Save transcript as plain text\n */\nexport async function saveTranscriptAsText(callId: string, textContent: string): Promise<void> {\n  await ensureDirectories();\n  const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n  await fs.writeFile(txtPath, textContent, 'utf-8');\n}\n\n/**\n * Get transcript by call ID\n */\nexport async function getTranscript(callId: string): Promise<Transcript | null> {\n  try {\n    const jsonPath = path.join(TRANSCRIPTS_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get transcript text by call ID\n */\nexport async function getTranscriptText(callId: string): Promise<string | null> {\n  try {\n    const txtPath = path.join(TRANSCRIPTS_DIR, `${callId}.txt`);\n    return await fs.readFile(txtPath, 'utf-8');\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Save analysis to JSON file\n */\nexport async function saveAnalysis(analysis: any): Promise<void> {\n  await ensureDirectories();\n  const jsonPath = path.join(ANALYSES_DIR, `${analysis.callId}.json`);\n  await fs.writeFile(jsonPath, JSON.stringify(analysis, null, 2), 'utf-8');\n}\n\n/**\n * Get analysis by call ID\n */\nexport async function getAnalysis(callId: string): Promise<any | null> {\n  try {\n    const jsonPath = path.join(ANALYSES_DIR, `${callId}.json`);\n    const data = await fs.readFile(jsonPath, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Get complete call data (call + transcript + analysis)\n */\nexport async function getCompleteCallData(callId: string): Promise<{\n  call: Call | null;\n  transcript: Transcript | null;\n  analysis: any | null;\n}> {\n  const [call, transcript, analysis] = await Promise.all([\n    getCallById(callId),\n    getTranscript(callId),\n    getAnalysis(callId),\n  ]);\n\n  return { call, transcript, analysis };\n}\n\n/**\n * Delete call and all associated data\n */\nexport async function deleteCall(callId: string): Promise<boolean> {\n  try {\n    // Remove from calls.json\n    const calls = await readCalls();\n    const filtered = calls.filter((call) => call.id !== callId);\n    await writeCalls(filtered);\n\n    // Delete transcript files\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.json`));\n    } catch {}\n    try {\n      await fs.unlink(path.join(TRANSCRIPTS_DIR, `${callId}.txt`));\n    } catch {}\n\n    // Delete analysis file\n    try {\n      await fs.unlink(path.join(ANALYSES_DIR, `${callId}.json`));\n    } catch {}\n\n    // Delete uploaded audio file (if exists)\n    const call = await getCallById(callId);\n    if (call?.filename) {\n      try {\n        await fs.unlink(getUploadPath(call.filename));\n      } catch {}\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Error deleting call:', error);\n    return false;\n  }\n}\n\n/**\n * Get storage statistics\n */\nexport async function getStorageStats(): Promise<{\n  totalCalls: number;\n  uploadedCalls: number;\n  transcribedCalls: number;\n  analyzedCalls: number;\n  errorCalls: number;\n  totalStorageBytes: number;\n}> {\n  const calls = await readCalls();\n\n  const stats = {\n    totalCalls: calls.length,\n    uploadedCalls: calls.filter((c) => c.status === 'pending').length,\n    transcribedCalls: calls.filter((c) => c.status === 'analyzing' || c.status === 'complete').length,\n    analyzedCalls: calls.filter((c) => c.status === 'complete').length,\n    errorCalls: calls.filter((c) => c.status === 'error').length,\n    totalStorageBytes: 0,\n  };\n\n  // Calculate total storage size\n  try {\n    const transcriptFiles = await fs.readdir(TRANSCRIPTS_DIR);\n    const analysisFiles = await fs.readdir(ANALYSES_DIR);\n    const uploadFiles = await fs.readdir(UPLOADS_DIR);\n\n    for (const file of transcriptFiles) {\n      const stat = await fs.stat(path.join(TRANSCRIPTS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of analysisFiles) {\n      const stat = await fs.stat(path.join(ANALYSES_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n\n    for (const file of uploadFiles) {\n      const stat = await fs.stat(path.join(UPLOADS_DIR, file));\n      stats.totalStorageBytes += stat.size;\n    }\n  } catch (error) {\n    console.error('Error calculating storage size:', error);\n  }\n\n  return stats;\n}\n"],"names":[],"mappings":"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"}